<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conway's Game of Life</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f7f7f7; }
        canvas {
            border: 2px solid #1f2937;
            touch-action: none; /* Prevents default touch behavior */
        }
        /* Custom scrollbar style for better aesthetics */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #e5e7eb; }
        ::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen flex items-center justify-center">

    <div class="max-w-4xl w-full bg-white shadow-2xl rounded-xl p-6 md:p-8 space-y-6">
        <h1 class="text-3xl font-extrabold text-gray-900 text-center">
            Conway's Game of Life
        </h1>
        <p id="status-message" class="text-center text-sm font-medium text-blue-600">
            Click on the grid to draw the initial state, then press Start!
        </p>

        <div class="flex flex-col lg:flex-row gap-6">
            <!-- Control Panel -->
            <div class="lg:w-1/3 space-y-4 bg-gray-50 p-4 rounded-lg shadow-inner">
                <div class="space-y-2">
                    <label for="grid-size" class="block text-sm font-semibold text-gray-700">Grid Density (<span id="density-value">40</span> cells)</label>
                    <input type="range" id="grid-size" min="10" max="100" value="40" step="10" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>

                <div class="space-y-2">
                    <label for="speed" class="block text-sm font-semibold text-gray-700">Simulation Speed (<span id="speed-value">200</span> ms/update)</label>
                    <!-- Speed is inversely related to slider value, so lower value is faster -->
                    <input type="range" id="speed" min="50" max="500" value="200" step="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>

                <div class="flex flex-col space-y-2">
                    <button id="start-btn" class="px-4 py-2 bg-green-600 text-white font-bold rounded-lg shadow-md hover:bg-green-700 transition duration-150 active:scale-95">
                        Start Simulation
                    </button>
                    <button id="reset-btn" class="px-4 py-2 bg-gray-500 text-white font-bold rounded-lg shadow-md hover:bg-gray-600 transition duration-150 active:scale-95">
                        Reset Grid & Stop
                    </button>
                    <button id="randomize-btn" class="px-4 py-2 bg-yellow-500 text-white font-bold rounded-lg shadow-md hover:bg-yellow-600 transition duration-150 active:scale-95">
                        Random Initial State
                    </button>
                </div>
            </div>

            <!-- Canvas Area -->
            <div class="lg:w-2/3 flex justify-center items-center relative">
                <canvas id="game-canvas" width="600" height="600" class="rounded-lg shadow-xl"></canvas>
            </div>
        </div>

    </div>

    <script>
        // Global state variables
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        // UI Elements
        const startBtn = document.getElementById('start-btn');
        const resetBtn = document.getElementById('reset-btn');
        const randomizeBtn = document.getElementById('randomize-btn');
        const gridSizeInput = document.getElementById('grid-size');
        const speedInput = document.getElementById('speed');
        const densityValueSpan = document.getElementById('density-value');
        const speedValueSpan = document.getElementById('speed-value');
        const statusMessage = document.getElementById('status-message');

        let currentGrid;
        let cols, rows;
        let cellSize;
        let intervalId = null;
        let isRunning = false;
        let updateInterval = parseInt(speedInput.value); // Initial interval

        // --- Core Functions ---

        /**
         * Initializes the game grid based on the current size input.
         * Fills the grid with dead (0) cells.
         */
        function initGame() {
            // Determine grid dimensions
            const size = parseInt(gridSizeInput.value);
            cols = size;
            rows = size;
            
            // Calculate cell size to fit the canvas
            cellSize = canvas.width / cols;

            // Initialize a new, empty grid (all dead cells)
            currentGrid = new Array(cols).fill(0).map(() => new Array(rows).fill(0));
            
            drawGrid();
            updateStatus("Click on the grid to draw the initial state, then press Start!");
        }

        /**
         * Fills the current grid with a random initial state (about 30% density).
         */
        function randomizeGrid() {
            if (isRunning) return; // Cannot randomize while running
            initGame(); // Reset size and grid first
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    currentGrid[i][j] = Math.random() < 0.3 ? 1 : 0;
                }
            }
            drawGrid();
            updateStatus("Random pattern set. Press Start to run the simulation.");
        }

        /**
         * Renders the current state of the grid onto the canvas.
         */
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#e5e7eb'; // Light gray for grid lines

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const x = i * cellSize;
                    const y = j * cellSize;

                    if (currentGrid[i][j] === 1) {
                        // Alive cell: Dark Blue
                        ctx.fillStyle = '#1f2937';
                        ctx.fillRect(x, y, cellSize, cellSize);
                    } else {
                        // Draw grid lines
                        ctx.strokeRect(x, y, cellSize, cellSize);
                    }
                }
            }
        }

        /**
         * Counts the number of live neighbors for a cell at (x, y).
         * Uses toroidal (wrapping) boundary conditions.
         */
        function countNeighbors(x, y) {
            let sum = 0;
            for (let i = -1; i < 2; i++) {
                for (let j = -1; j < 2; j++) {
                    // Skip the cell itself
                    if (i === 0 && j === 0) continue;

                    // Toroidal wrapping logic
                    const col = (x + i + cols) % cols;
                    const row = (y + j + rows) % rows;
                    
                    sum += currentGrid[col][row];
                }
            }
            return sum;
        }

        /**
         * Calculates the next state of the grid based on Conway's rules.
         */
        function updateGame() {
            const nextGrid = new Array(cols).fill(0).map(() => new Array(rows).fill(0));

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const state = currentGrid[i][j];
                    const neighbors = countNeighbors(i, j);

                    if (state === 0 && neighbors === 3) {
                        // Rule 1: Reproduction (Dead cell with exactly 3 neighbors comes alive)
                        nextGrid[i][j] = 1;
                    } else if (state === 1 && (neighbors < 2 || neighbors > 3)) {
                        // Rule 2 & 3: Death (Live cell with fewer than 2 or more than 3 neighbors dies)
                        nextGrid[i][j] = 0;
                    } else {
                        // Rule 4: Survival (Otherwise, the state remains the same)
                        nextGrid[i][j] = state;
                    }
                }
            }
            currentGrid = nextGrid;
            drawGrid();
        }

        // --- Interaction Handlers ---

        /**
         * Toggles the state of a cell at a given canvas position.
         */
        function toggleCell(event) {
            if (isRunning) return; // Cannot modify grid while running

            const rect = canvas.getBoundingClientRect();
            // Calculate mouse position relative to the canvas
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clientX = event.clientX || (event.touches ? event.touches[0].clientX : 0);
            const clientY = event.clientY || (event.touches ? event.touches[0].clientY : 0);
            
            const mouseX = (clientX - rect.left) * scaleX;
            const mouseY = (clientY - rect.top) * scaleY;

            // Determine the grid coordinates
            const i = Math.floor(mouseX / cellSize);
            const j = Math.floor(mouseY / cellSize);

            if (i >= 0 && i < cols && j >= 0 && j < rows) {
                // Toggle state: 0 -> 1 or 1 -> 0
                currentGrid[i][j] = currentGrid[i][j] === 0 ? 1 : 0;
                drawGrid();
            }
        }
        
        // --- Simulation Control ---

        function startSimulation() {
            if (isRunning) {
                // Pause
                clearInterval(intervalId);
                isRunning = false;
                startBtn.textContent = 'Resume Simulation';
                startBtn.classList.remove('bg-red-600');
                startBtn.classList.add('bg-green-600');
                updateStatus("Simulation Paused. You can now edit the grid again.");
                gridSizeInput.disabled = false;
            } else {
                // Start or Resume
                if (!currentGrid || currentGrid.length === 0 || cols !== parseInt(gridSizeInput.value)) {
                    // Re-initialize if grid size changed or it's the first run
                    initGame();
                }

                intervalId = setInterval(updateGame, updateInterval);
                isRunning = true;
                startBtn.textContent = 'Pause Simulation';
                startBtn.classList.remove('bg-green-600');
                startBtn.classList.add('bg-red-600');
                updateStatus(`Running at ${updateInterval} ms/update...`);
                // Disable grid density modification while running
                gridSizeInput.disabled = true;
            }
        }

        function resetSimulation() {
            // Stop loop
            clearInterval(intervalId);
            intervalId = null;
            isRunning = false;
            
            // Reset UI
            startBtn.textContent = 'Start Simulation';
            startBtn.classList.remove('bg-red-600');
            startBtn.classList.add('bg-green-600');
            gridSizeInput.disabled = false;

            // Reset grid data
            initGame();
        }
        
        // --- Event Listeners ---

        // Grid Size and Speed display updates
        gridSizeInput.addEventListener('input', (e) => {
            densityValueSpan.textContent = e.target.value;
            // Automatically reset when grid size changes to apply new dimensions
            resetSimulation(); 
        });

        speedInput.addEventListener('input', (e) => {
            updateInterval = parseInt(e.target.value);
            speedValueSpan.textContent = updateInterval;
            
            // If running, restart the interval with the new speed
            if (isRunning) {
                clearInterval(intervalId);
                intervalId = setInterval(updateGame, updateInterval);
                updateStatus(`Running at new speed: ${updateInterval} ms/update...`);
            }
        });

        // Control buttons
        startBtn.addEventListener('click', startSimulation);
        resetBtn.addEventListener('click', resetSimulation);
        randomizeBtn.addEventListener('click', randomizeGrid);

        // Canvas drawing (Mouse and Touch)
        canvas.addEventListener('click', toggleCell);
        canvas.addEventListener('mousedown', (e) => {
            if (isRunning) return;
            // Prevent default drag/selection
            e.preventDefault(); 
            // Add mousemove listener for continuous drawing
            canvas.addEventListener('mousemove', toggleCell);
        });
        document.addEventListener('mouseup', () => {
            // Remove mousemove listener globally when mouse is released
            canvas.removeEventListener('mousemove', toggleCell);
        });

        // Touch input for drawing
        canvas.addEventListener('touchstart', (e) => {
             if (isRunning) return;
             e.preventDefault();
             // Initial toggle on touch start
             toggleCell(e);
             canvas.addEventListener('touchmove', toggleCell);
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
             canvas.removeEventListener('touchmove', toggleCell);
        });

        // Utility to update the status message
        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.classList.remove('text-red-600', 'text-blue-600');
            statusMessage.classList.add(isError ? 'text-red-600' : 'text-blue-600');
        }

        // Initial setup on window load
        window.onload = initGame;
    </script>
</body>
</html>
